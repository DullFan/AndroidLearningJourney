# 对象的分配

创建时间: February 24, 2023 12:43 AM
标签: Java

# JVM中对象的创建过程

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706096108-723798db-fdd9-4f8d-b0da-9be7302a3681.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706096108-723798db-fdd9-4f8d-b0da-9be7302a3681.png)

# 对象的内存分配

虚拟机遇到一条new指令时，首先检查是否被类加载器加载，如果没有，那必须先执行相应的类加载过程。类加载就是把class加载到JVM的运行时数据区的过程。

## 1）检查加载

首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（符号引用 ：符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。

符号引用 ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，JAVA在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址(实际地址)，就用符号引用来代替，而在类的解析阶段（后续JVM类加载会具体讲到）就是为了把这个符号引用转化成为真正的地址的阶段。

比如:一个java类（假设为People类）被编译成一个class文件时，如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，因此只能使用符号引用（org.simple.Tool）来代替。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以将符号org.simple.Tool替换为Tool类的实际内存地址。

## 2）分配内存

接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。有以下几种方式:

### **指针碰撞**

如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706258681-414c88f1-1913-4f47-9abd-dd9e7f98f6a8.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706258681-414c88f1-1913-4f47-9abd-dd9e7f98f6a8.png)

### **空闲列表**

如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706273555-60c8203e-9fe8-4b5d-a206-75f913634a15.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706273555-60c8203e-9fe8-4b5d-a206-75f913634a15.png)

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。如果是Serial(单线程收集器)、ParNew(多线程收集器,只能处理新生代)等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。

# 并发安全

内存分配时候出现的并发问题：单线程下，“**指针碰撞**” 和 “**空闲列表**”分配内存不会有线程安全问题，实际开发过程中，创建对象是很频繁的事情，而且是多线程环境，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

## CAS机制

CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是 设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706343705-0c983e3d-307f-4e94-b6b2-6a92d875d9c3.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706343705-0c983e3d-307f-4e94-b6b2-6a92d875d9c3.png)

## 分配缓冲

另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer）,JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。

**TLAB**的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。

**TLAB**只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个**TLAB**用满（分配指针top撞上分配极限end了），就新申请一个**TLAB**。

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706376935-4ee98660-6224-4dce-9ab2-32c22664d7e2.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706376935-4ee98660-6224-4dce-9ab2-32c22664d7e2.png)

# 对象的分配策略

## **逃逸分析**

分析对象的作用域是否会逃逸出方法之外分析对象动态作用域。当一个对象在方法中定义后，它可能被外部方法所引用。比如：调用参数传递到其他方法中，这种称之为方法逃逸。甚至还有可能被外部线程访问到，例如：赋值给其他线程中访问的变量，这个称之为线程逃逸。从不逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度。

```java
public class EscapeTest {
    public static Object globalObj;

    // 给全局变量赋值，发生逃逸
    public void globalVariableEscape() {
        globalObj= new Object();
    }

    // 方法返回值，发生逃逸
    public Object methodEscape() {
        return new Object();
    }

    // 实例引用发生逃逸
    public void instanceEscape() {
        test(this);
    }

     private static void allocate() {
       synchronized (new Object()){
            //仅创建线程可见,对象无逃逸
        }
         //无逃逸
        MyObject myObject = new MyObject(1,1);
    }
}
```

逃逸分析的触发前提条件必须触发JIT

### 解释执行与JIT

Java程序在运行的时候，主要就是执行字节码指令，一般这些指令会按照顺序解释执行，这种就是解释执行。

那些被频繁调用的代码，比如调用次数很高或者在 for 循环里的那些代码,如果按照解释执行，效率	是非常低的。

以上的这些代码称为热点代码。

所以，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化。完成这个任务的编译器，就称为即时编译器（Just In Time Compiler），简称 JIT 编译器(触发条件就是多次调用方法或多次执行循环体)。

在HotSpot虚拟机中的热点探测是 JIT 优化的条件，热点探测是基于计数器的热点探测，采用这种方法的虚拟机会为每个方法建立计数器统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”

虚拟机为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发 JIT 编译。

**方法调用计数器**的默认阈值在 客户端模式下是 1500 次，在服务端模式下是 10000 次(我们用的都是服务端，java –version查询)，可通过 -XX:CompileThreshold = 10000 来设定

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706524173-34249c78-9d9b-441d-b711-464a25baf0c9.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706524173-34249c78-9d9b-441d-b711-464a25baf0c9.png)

通过 java -XX:+PrintFlagsFinal –version查询:

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706542988-ef54aa80-338c-4c74-b908-7ca49ef69405.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706542988-ef54aa80-338c-4c74-b908-7ca49ef69405.png)

**回边计数器在服务端模式下是10700。**

当判断出对象不发生逃逸时，编译器可以使用逃逸分析的结果作一些代码优化

**栈上分配**: JVM提供了一种叫做栈上分配的概念，针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈(线程私有的，属于栈内存)上，这样，随着方法的调用结束，栈空间的回收就会随着将栈上分配的打散后的对象回收掉，不再给gc增加额外的无用负担，从而提升应用程序整体的性能

**同步消除**：线程同步降低了并发性和程序性能。

锁消除：当确定对象不会发生线程逃逸时，可消除该对象不必要的同步操作（永不会竞争）。具体来说，JVM在编译器运行时会扫描代码，当检查到那些不可能存在共享区竞争，但却有互斥同步的代码，直接将这样的多此一举的同步消除

**锁粗化**：JVM针对那些反复在一段代码中对同一对象加锁的情况，将同步锁放在最外层包住这里面的多次同步锁，同时取消内部的同步锁

**标量替换**：标量是指一个数据无法分解成更小的数据，基础类型的数据都算是标量，对象可以被分解成其他的成员变量，所以说变量不是标量，那么标量替换是指在运行期间，不必要创建对象，而是改成创建对象的成员变量，不仅可以让对象成员在栈上分配和读写之外，还可以为后一步的优化技术创造了条件。

代码示例：

```java
//-XX:-DoEscapeAnalysis -XX:+PrintGC
public class Test {

    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 50000000; i++) {
            allocate();
        }
        System.out.println("耗时"+(System.currentTimeMillis() - start)+"ms");
        Thread.sleep(600000);
    }

    private static void allocate() {
        MyObject myObject = new MyObject(1,1);
    }

    static class MyObject{
        int a;
        double d;

        public MyObject(int a, double d) {
            this.a = a;
            this.d = d;
        }
    }
}
```

这段代码在调用的过程中Myboject这个对象属于不可逃逸，JVM可以做栈上分配

**开启逃逸分析(JVM默认开启)**

```java
-XX:+DoEscapeAnalysis
```

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706616314-28cfa925-ebdf-4fbe-abb5-e120dbdd39b9.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706616314-28cfa925-ebdf-4fbe-abb5-e120dbdd39b9.png)

执行速度

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706638095-0fc58ef3-9e68-4128-b6ab-f1e6d0ae5ad6.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706638095-0fc58ef3-9e68-4128-b6ab-f1e6d0ae5ad6.png)

**关闭逃逸分析**

```java
-XX:-DoEscapeAnalysis
```

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706655906-2098b24e-212f-41c9-b2b6-aa42a7adaa83.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706655906-2098b24e-212f-41c9-b2b6-aa42a7adaa83.png)

执行速度

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706673435-4e070da6-ddef-4f71-bffe-c6252a9d0348.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706673435-4e070da6-ddef-4f71-bffe-c6252a9d0348.png)

测试结果可见，开启逃逸分析对代码的执行性能有很大的影响,那为什么有这个影响？

## **分析**

如果是逃逸分析出来的对象可以在栈上分配的话，那么该对象的生命周期就跟随线程了，就不需要垃圾回收，如果是频繁的调用此方法则可以得到很大的性能提高。采用了逃逸分析后，满足逃逸的对象在栈上分配

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706806048-bc05014c-9a1b-4a73-9e3b-be774ee6a98f.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706806048-bc05014c-9a1b-4a73-9e3b-be774ee6a98f.png)

没有开启逃逸分析，对象都在堆上分配，会频繁触发垃圾回收（垃圾回收会影响系统性能），导致代码运行慢

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706821424-a9ca5f54-06f9-4962-85ee-2c7a5fc993a7.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706821424-a9ca5f54-06f9-4962-85ee-2c7a5fc993a7.png)

**大对象直接进入老年代**

大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。

大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。

在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们。而当复制对象时，大对象就意味着高额的内存复制开销。HotSpot 虚拟机提供了-XX:PretenureSizeThreshold = 5(最大值只有15 因为他是4位二进制码) 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。这样做的目的：1.避免大量内存复制,2.避免提前进行垃圾回收，明明内存有空间进行分配

**对象优先在Eden区分配**

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。

**长期存活对象进入老年区**

HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器，存储在对象头中。

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706921296-312fdba0-b329-40d3-8dd8-67ea1cca7a7b.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706921296-312fdba0-b329-40d3-8dd8-67ea1cca7a7b.png)

如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(并发的垃圾回收器默认为15),CMS是6时，就会被晋升到老年代中。

- XX:MaxTenuringThreshold调整

**对象年龄动态判定**

为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

**空间分配担保**

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706992268-22159e50-7e9d-4979-a99f-ee72940b3faa.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645706992268-22159e50-7e9d-4979-a99f-ee72940b3faa.png)

**内存空间初始化**

（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

**设置**

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes在Java hotspot VM内部表示为类元数据）、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。

**对象初始化**

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。

**对象的内存布局**

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645707276058-1f237dc4-e0de-4070-86b9-dfd57eea92ee.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645707276058-1f237dc4-e0de-4070-86b9-dfd57eea92ee.png)

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

**对象头**包括两部分信息，**第一部分**用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。**第二部分**是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那么在对象头中还有一块用于记录数组长度的数据。

**实例数据**:主要是存放类的数据信息，父类的信息，对象字段属性信息。

**对齐填充**并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。

**对象的访问定位**

建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。

**句柄**

如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改.(指向一个人的代号,人可以变,代号不能变)

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645707445557-31647134-2093-4254-9e7b-29666cb53795.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645707445557-31647134-2093-4254-9e7b-29666cb53795.png)

**直接指针**

如果使用直接指针访问， reference中存储的直接就是对象地址。(直接报你的身份证找你)

![https://cdn.nlark.com/yuque/0/2022/png/26240361/1645707476344-6c73053c-62a1-4b4a-996f-653c599d00ed.png](https://cdn.nlark.com/yuque/0/2022/png/26240361/1645707476344-6c73053c-62a1-4b4a-996f-653c599d00ed.png)

这两种对象访问方式各有优势，使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

对Sun HotSpot而言,它是使用直接指针访问方式进行对象访问的。